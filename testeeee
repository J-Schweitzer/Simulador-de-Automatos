import sys
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QPushButton, QVBoxLayout, QLineEdit, QHBoxLayout, QFileDialog
from PyQt5.QtCore import QTimer, Qt, QPointF
from PyQt5.QtGui import QPainter, QFont
import json
import math

class Automato:
    def __init__(self):
        self.estados = set()
        self.transicoes = {}
        self.estados_ativos = set()  # Usado para armazenar múltiplos estados ativos
        self.estados_finais = set()

    def adicionar_transicao(self, origem, simbolo, destino):
        """Adiciona uma transição ao autômato. Suporta transições em vazio usando uma string vazia ('') como símbolo."""
        self.estados.add(origem)
        self.estados.add(destino)
        if (origem, simbolo) not in self.transicoes:
            self.transicoes[(origem, simbolo)] = set()
        self.transicoes[(origem, simbolo)].add(destino)

    def definir_estado_inicial(self, estado):
        """Define o estado inicial do autômato."""
        self.estados_ativos = self.fecho_epsilon(estado) 



    def definir_estados_finais(self, finais):
        """Define os estados finais do autômato."""
        self.estados_finais = set(finais)

    def fecho_epsilon(self, estados):
        """Calcula o fecho-\(\varepsilon\) de um conjunto de estados."""
        fecho = set(estados)
        stack = list(estados)
        while stack:
            s = stack.pop()
            # Verifica transições em vazio a partir do estado atual
            for destino in self.transicoes.get((s, ''), []):
                if destino not in fecho:
                    fecho.add(destino)
                    stack.append(destino)
        return fecho

    def proximo_estado(self, simbolo):
        """Tenta realizar uma transição com o símbolo atual ou uma transição em vazio."""
        novos_estados = set()
        
        for estado in self.estados_ativos:
            if (estado, simbolo) in self.transicoes:
                novos_estados.update(self.transicoes[(estado, simbolo)])

        # Calcula o fecho-\(\varepsilon\) dos novos estados
        self.estados_ativos = self.fecho_epsilon(novos_estados)

    def salvar(self, nome_arquivo):
        """Salva o autômato em um arquivo JSON."""
        dados = {
            'estados': list(self.estados),
            'transicoes': {
                f"{origem},{simbolo}": list(destinos)
                for (origem, simbolo), destinos in self.transicoes.items()
            },
            'estados_ativos': list(self.estados_ativos),
            'estados_finais': list(self.estados_finais),
        }
        with open(nome_arquivo, 'w') as f:
            json.dump(dados, f, indent=4)

    def carregar(self, nome_arquivo):
        """Carrega o autômato a partir de um arquivo JSON."""
        try:
            with open(nome_arquivo, 'r') as f:
                dados = json.load(f)
                
                # Verifica se as chaves esperadas estão presentes
                if 'estados' in dados and 'transicoes' in dados and 'estados_finais' in dados:
                    self.estados = set(dados['estados'])
                    self.transicoes = {
                        (origem, simbolo): set(destinos)
                        for transicao, destinos in dados['transicoes'].items()
                        for origem, simbolo in [transicao.split(',')]
                    }
                    self.estados_ativos = set(dados['estados_ativos'])
                    self.estados_finais = set(dados['estados_finais'])
                else:
                    raise KeyError("Arquivo JSON inválido: chave(s) ausente(s).")
        except (json.JSONDecodeError, KeyError) as e:
            print(f"Erro ao carregar o autômato: {e}")

class SimulatorApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Configuração e Simulação de Autômato")
        self.setGeometry(100, 100, 800, 600)

        # Layouts para configuração
        self.label = QLabel("Configuração do Autômato:", self)
        self.label.setAlignment(Qt.AlignCenter)
        
        # Campos de entrada para configuração
        self.input_estado_inicial = QLineEdit(self)
        self.input_estado_inicial.setPlaceholderText("Estado Inicial")
        
        self.input_estados_finais = QLineEdit(self)
        self.input_estados_finais.setPlaceholderText("Estados Finais (separados por vírgula)")
        
        self.input_transicao_origem = QLineEdit(self)
        self.input_transicao_origem.setPlaceholderText("Estado de Origem")
        
        self.input_transicao_simbolo = QLineEdit(self)
        self.input_transicao_simbolo.setPlaceholderText("Símbolo")
        
        self.input_transicao_destino = QLineEdit(self)
        self.input_transicao_destino.setPlaceholderText("Estado de Destino")
        
        self.botao_adicionar_transicao = QPushButton("Adicionar Transição", self)
        self.botao_adicionar_transicao.clicked.connect(self.adicionar_transicao)

        self.input_cadeia = QLineEdit(self)
        self.input_cadeia.setPlaceholderText("Digite a cadeia para simulação")

        self.start_button = QPushButton("Iniciar Simulação", self)
        self.start_button.clicked.connect(self.iniciar_simulacao)

        # Botões para salvar e carregar
        self.botao_salvar = QPushButton("Salvar Projeto", self)
        self.botao_salvar.clicked.connect(self.salvar_projeto)

        self.botao_carregar = QPushButton("Carregar Projeto", self)
        self.botao_carregar.clicked.connect(self.carregar_projeto)

        # Layout principal
        layout = QVBoxLayout()
        layout.addWidget(self.label)
        
        # Layout para configurações do autômato
        layout_config = QHBoxLayout()
        layout_config.addWidget(self.input_estado_inicial)
        layout_config.addWidget(self.input_estados_finais)
        layout.addLayout(layout_config)
        
        layout_transicoes = QHBoxLayout()
        layout_transicoes.addWidget(self.input_transicao_origem)
        layout_transicoes.addWidget(self.input_transicao_simbolo)
        layout_transicoes.addWidget(self.input_transicao_destino)
        layout_transicoes.addWidget(self.botao_adicionar_transicao)
        layout.addLayout(layout_transicoes)
        
        layout.addWidget(self.input_cadeia)
        layout.addWidget(self.start_button)

        # Adicionar os botões ao layout
        layout.addWidget(self.botao_salvar)
        layout.addWidget(self.botao_carregar)

        self.setLayout(layout)

        # Timer para simulação
        self.timer = QTimer()
        self.timer.timeout.connect(self.proximo_passo)

        # Inicializar o autômato
        self.automato = Automato()
        self.cadeia = ""
        self.index = 0

    def adicionar_transicao(self):
        origem = self.input_transicao_origem.text()
        simbolo = self.input_transicao_simbolo.text()
        destino = self.input_transicao_destino.text()

        if origem and simbolo and destino:
            self.automato.adicionar_transicao(origem, simbolo, destino)
            self.label.setText(f"Transição adicionada: {origem} --{simbolo}--> {destino}")
        else:
            self.label.setText("Por favor, preencha todos os campos da transição.")

    def iniciar_simulacao(self):
        estado_inicial = self.input_estado_inicial.text()
        estados_finais = self.input_estados_finais.text().split(',')

        # Configurações iniciais
        if estado_inicial:
            self.automato.definir_estado_inicial(estado_inicial)
        self.automato.definir_estados_finais(estados_finais)
        
        # Obter a cadeia do campo de entrada
        self.cadeia = self.input_cadeia.text()
        
        # Resetar o índice e iniciar a simulação
        if self.cadeia:
            self.index = 0
            self.label.setText("Simulação em andamento...")
            self.timer.start(1000)  # Intervalo de 1 segundo
        else:
            self.label.setText("Por favor, insira uma cadeia válida.")

    def proximo_passo(self):
        if self.index < len(self.cadeia):
            simbolo = self.cadeia[self.index]
            self.automato.proximo_estado(simbolo)
            self.index += 1

            if self.automato.estados_ativos:
                self.label.setText(f"Estados ativos: {', '.join(self.automato.estados_ativos)}")
                self.update()  # Atualiza a tela para chamar o paintEvent
            else:
                self.label.setText("Cadeia rejeitada.")
                self.timer.stop()
        else:
            if self.automato.estados_ativos & self.automato.estados_finais:
                self.label.setText("Cadeia aceita!")
            else:
                self.label.setText("Cadeia rejeitada.")
        self.timer.stop()


    
    def salvar_projeto(self):
        nome_arquivo, _ = QFileDialog.getSaveFileName(self, "Salvar Projeto", "", "Arquivos JSON (*.json)")
        if nome_arquivo:
            self.automato.salvar(nome_arquivo)

    def carregar_projeto(self):
        nome_arquivo, _ = QFileDialog.getOpenFileName(self, "Carregar Projeto", "", "Arquivos JSON (*.json)")
        if nome_arquivo:
            self.automato.carregar(nome_arquivo)
            # Atualizar a interface após carregar o projeto
            self.atualizar_interface()

    def atualizar_interface(self):
        self.input_estado_inicial.setText(self.automato.estado_atual if self.automato.estado_atual else "")
        self.input_estados_finais.setText(', '.join(self.automato.estados_finais))
        self.input_transicao_origem.clear()
        self.input_transicao_simbolo.clear()
        self.input_transicao_destino.clear()
        self.input_cadeia.clear()

def paintEvent(self, event):
    qp = QPainter()
    qp.begin(self)

    qp.setFont(QFont("Arial", 10))
    center_x, center_y = 400, 300  # Centro do círculo
    radius = 200  # Raio do círculo

    num_estados = len(self.automato.estados)
    if num_estados > 0:
        # Distribuir estados em um círculo
        estados_pos = {}
        angle_step = 2 * math.pi / num_estados
        for i, estado in enumerate(self.automato.estados):
            angle = i * angle_step
            x = center_x + radius * math.cos(angle)
            y = center_y + radius * math.sin(angle)
            estados_pos[estado] = QPointF(x, y)

        # Desenhar estados
        for estado, pos in estados_pos.items():
            if estado in self.automato.estados_ativos:
                qp.setBrush(Qt.green)  # Estados ativos em verde
            elif estado in self.automato.estados_finais:
                qp.setBrush(Qt.red)  # Estado final em vermelho
            else:
                qp.setBrush(Qt.white)  # Outros estados em branco
            qp.drawEllipse(pos, 20, 20)
            qp.drawText(int(pos.x()) - 10, int(pos.y()) - 10, estado)  # Ajuste para centralizar o texto

        # Desenhar transições
        curve_count = {}
        for (origem, simbolo), destinos in self.automato.transicoes.items():
            origem_pos = estados_pos[origem]
            for destino in destinos:
                destino_pos = estados_pos[destino]
                qp.drawLine(origem_pos, destino_pos)

                # Calcular o ponto médio para a curva
                mid_x = (origem_pos.x() + destino_pos.x()) / 2
                mid_y = (origem_pos.y() + destino_pos.y()) / 2

                # Desenhar a curva
                if (origem, destino) not in curve_count:
                    curve_count[(origem, destino)] = 0
                curve_count[(origem, destino)] += 1

                # Adicionar um deslocamento vertical para cada curva entre os mesmos estados
                offset = (curve_count[(origem, destino)] - 1) * 10
                qp.drawText(int(mid_x), int(mid_y + offset), simbolo)  # Ajusta a posição do texto
    else:
        qp.setBrush(Qt.black)
        qp.drawText(center_x, center_y, "Nenhum estado para mostrar!")

    qp.end()





if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = SimulatorApp()
    window.show()
    sys.exit(app.exec_())

